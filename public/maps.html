<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>BankMaps • Tract Choropleth</title>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<style>
  html,body{height:100%;margin:0}
  body{font-family:Arial,sans-serif;background:#f6f8fb}
  #map{position:fixed;inset:0;width:100vw;height:100vh}
  aside{
    position:fixed;top:16px;left:16px;z-index:2;background:#fff;
    padding:12px 14px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.08);
    width:340px
  }
  label{font-size:12px;color:#333}
  select{width:100%;padding:8px;border:1px solid #ccc;border-radius:6px;margin-bottom:8px}
  #status{font-size:12px;color:#666;min-height:18px}
</style>
</head>
<body>
<div id="map"></div>

<aside>
  <label>Year</label>
  <select id="year">
    <option value="2024" selected>2024</option>
  </select>

  <label>Lender</label>
  <select id="lender"></select>
  <div id="status">Loading…</div>
</aside>

<script>
let map;
let prevGeoids = new Set();
let currentYear = "2024";

// Background style (your custom style)
const MAP_STYLE = 'mapbox://styles/stuartmaps/cmhmpa5i4000s01ql6lrwh3tk';

// Year → tileset mapping (add more years as needed)
const TILESETS = {
  "2024": { id: 'tracts2024', url: 'mapbox://stuartmaps.58y5r823', layer: '2024-1pvgy8' }
};

// Choropleth color ramp (uses feature-state "value")
function fillPaint() {
  return {
    'fill-color': [
      'case',
      ['has', 'value', ['feature-state']],
      ['interpolate', ['linear'], ['to-number', ['feature-state', 'value']],
        0,   '#f0f4ff',
        5,   '#c8d8ff',
        20,  '#91b4ff',
        50,  '#5f90f6',
        100, '#2b6ce3',
        250, '#174db6',
        500, '#0b3366'
      ],
      'rgba(0,0,0,0)'
    ],
    'fill-opacity': [
      'case',
      ['has', 'value', ['feature-state']], 0.85, 0
    ]
  };
}

// Wait until the vector source is fully ready
function waitForTiles(sourceId) {
  return new Promise((resolve) => {
    if (map.isSourceLoaded(sourceId)) return resolve();
    const onData = (e) => {
      if (e.sourceId === sourceId && map.isSourceLoaded(sourceId)) {
        map.off('sourcedata', onData);
        resolve();
      }
    };
    map.on('sourcedata', onData);
  });
}

async function init(){
  const status = document.getElementById('status');

  // Mapbox token
  const { token } = await fetch('/api/mapbox-token').then(r=>r.json()).catch(()=>({token:''}));
  if(!token || !token.startsWith('pk.')) { status.textContent='Mapbox token missing or invalid.'; return; }

  // Map
  mapboxgl.accessToken = token;
  map = new mapboxgl.Map({
    container:'map',
    style: MAP_STYLE,
    center:[-98.5,39.8],
    zoom:3.5
  });
  map.addControl(new mapboxgl.NavigationControl(),'top-right');
  map.on('error', e => { status.textContent = 'Map error: ' + (e?.error?.message || JSON.stringify(e)); });
  await new Promise(res => map.once('load', res));

  // Optional background brightness slider
  const slider = document.createElement('input');
  slider.type = 'range'; slider.min = 0; slider.max = 1; slider.step = 0.05; slider.value = 0.8;
  slider.style.position = 'fixed'; slider.style.top = '16px'; slider.style.right = '16px'; slider.style.zIndex = '10';
  slider.title = 'Background brightness';
  document.body.appendChild(slider);
  slider.oninput = e => map.setPaintProperty('background', 'background-opacity', parseFloat(e.target.value));

  // Year change
  document.getElementById('year').addEventListener('change', async e => {
    currentYear = e.target.value;
    await updateTileset();
    await loadCounts();
  });

  // Lender dropdown
  const dd = document.getElementById('lender');
  const L = await fetch('/api/maps').then(r=>r.json()).catch(()=>({lenders:[]}));
  dd.innerHTML = (L.lenders||[]).map(n=>`<option>${n}</option>`).join('');
  dd.addEventListener('change', loadCounts);

  await updateTileset();
  await loadCounts();
}

async function updateTileset(){
  const t = TILESETS[currentYear];
  if(!t){ alert(`No tileset defined for year ${currentYear}`); return; }

  // Remove existing
  for (const yr in TILESETS){
    const l = TILESETS[yr];
    if(map.getLayer(l.id+'-fill')) map.removeLayer(l.id+'-fill');
    if(map.getLayer(l.id+'-outline')) map.removeLayer(l.id+'-outline');
    if(map.getSource(l.id)) map.removeSource(l.id);
  }

  // Add tileset (promote GEOID as feature id)
  map.addSource(t.id, { type: 'vector', url: t.url, promoteId: 'GEOID' });

  map.addLayer({
    id: t.id+'-fill',
    type: 'fill',
    source: t.id,
    'source-layer': t.layer,
    paint: fillPaint()
  });

  map.addLayer({
    id: t.id+'-outline',
    type: 'line',
    source: t.id,
    'source-layer': t.layer,
    paint:{ 'line-color':'#ffffff','line-width':0.3,'line-opacity':0.6 }
  });
}

async function loadCounts(){
  const lender = document.getElementById('lender').value;
  const status = document.getElementById('status');
  const t = TILESETS[currentYear];
  if(!t){ status.textContent = `No tileset for ${currentYear}`; return; }

  status.textContent = 'Loading counts…';
  // API uses DB fields: stfid → GEOID, datayear
  const res = await fetch(`/api/map-data-tracts?lender=${encodeURIComponent(lender)}&year=${currentYear}`);
  if(!res.ok){ status.textContent = 'Error: '+(await res.text()); return; }
  const data = await res.json();

  const counts = new Map((data.rows||[]).map(r => [String(r.GEOID), r.count]));

  status.textContent = `Loaded ${counts.size} tracts. Waiting for tiles…`;
  await waitForTiles(t.id);

  // Clear previous feature-state values
  for (const geoid of prevGeoids) {
    map.setFeatureState({ source: t.id, sourceLayer: t.layer, id: geoid }, { value: null });
  }
  prevGeoids.clear();

  // Apply new values
  let applied = 0;
  for (const [geoid, value] of counts.entries()) {
    map.setFeatureState(
      { source: t.id, sourceLayer: t.layer, id: geoid },
      { value }
    );
    prevGeoids.add(geoid);
    applied++;
  }

  status.textContent = `Colored ${applied} tracts.`;
}

init();
</script>
</body>
</html>
